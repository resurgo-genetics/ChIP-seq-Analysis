## heatMap03NCTK08MB01.R
## Version 3.8.1 Tuesday, January 26th, 2015.
## Created By: Nathan Cormier, Tyler Kolisnik, and Mark Bieda.

## DESCRIPTION:
# This program takes the heat map data file generated by Homer as input and
# creates a heatmap of the sequence read coverage around each TSS, where the 
# scores on the heatmap are the square roots of the sequence coverage values.

## DIRECTIONS:
# Change the appropriate parameters.
# Run the program.
# Output is three files into the outputDirectory: 
# an extendedReads_estimatedFragmentSize.bed file, an heatMapData.txt file and heatmap, runName_heatmap.tif. 

## Run Speed: Usually less than 15 minutes, depending on inputFile size.

## IMPORTANT HOMER SPECIES AND GENOME ASSEMBLY INFORMATION:
# The correct species and genome assembly must be installed within Homer for this program to work. 
# Note: This depends on Homer, Python and Perl being installed correctly. Homer must be in the path.

# To install this:

# Run this perl command to see potential lists of genomes, be sure to change /home/user/Homer to the correct path where you have installed Homer:
# perl /home/user/Homer//configureHomer.pl -list

# From this list get the correct genome code 
# Run this perl command to install the genome, example for mm10 (mus musculus), be sure to change /home/user/Homer to the correct path where you have installed Homer:
# perl /home/user/Homer//configureHomer.pl -install mm10

# The genomeAssembly parameter within the parameter block  must correctly indicate the species & assembly. 
# Change the genome assembly to the new species, example for mm10:
# genomeAssembly <- "mm10"

## EXAMPLE INPUT:
# inputFile <- "/home/user/inputData/GATA1_mappedReads.bed"
# outputDirectory <- "/home/user/inputData/heatMap" 
# keplerBinLocation <- "/home/user/keplerBin" 
# runName <- "Test1" 
# extendReads <- "yes"
# genomeAssembly <- "hg19"
# aroundTSSrange <- 20000 
# estimatedFragmentSize <- 500
# binSize <- 400
# lowerLimit <- 2
# upperLimit <- 15
# TSStoUse <- 0 


##########################   SET PARAMETERS HERE   ####################################

## The input file, output directory and keplerBin must be complete file paths with no trailing /
inputFile <- "/home/tylerk/CWF1runtests/nohomer40972/40972fastqTestJanuary_mappedReads.bed" # This must be a .bed mapped reads file with no header line
outputDirectory <- "/home/tylerk/CWF1runtests/40972heatmap" # The directory where all output files will be located
keplerBinLocation <- "/home/tylerk/CWF1/keplerBin" # The keplerBin where the python scripts are located

runName <- "heatmaptest40972v1" # runName will be used as a prefix in the output file names
extendReads <- "yes" # If set to yes, reads will be extended, set to "no" to leave them unaltered
genomeAssembly <- "hg19" # Assembly of genome being used, see above example for more info
aroundTSSrange <- 10000 #this is the total range of xaxis. If y=aroundTSSrange/2, then the axis goes from -y to y
estimatedFragmentSize <- 500 # Numeric estimated fragment size after sonication
binSize <- 400 # Numeric size of bin (in base pairs) to be used for heat map generation

lowerLimit <- 2 # Numeric lower limit of the smallest coverage value to be included on the grey scale. any coverage values below this will be white on the heatmap.
upperLimit <- 15 # Numeric upper limit of the largest coverage value to be included on the grey scale, any coverage values above this will be red on the heatmap. If this value exceeds the maximum read density it will cause errors.
TSStoUse <- 0  # Numeric maximum number of Transcription Start Sites (TSSs) to show in the heatmap. The top scoring TSSs will be shown. Scoring is number of sequence reads within range of the TSS. Will use all possible TSSs when set to 0.

##########################   END PARAMETER BLOCK   ####################################

##############################    FUNCTION BLOCK      #################################
isyes <- function(x){ #designed to return TRUE if x is some variant of "yes"
  xmod <- toupper(x)
  if (xmod %in% c("Y","YES"))
  {TRUE} else {FALSE}
}

#myHeatMap function block
myHeatMap <- function(x, ...){
	min <- min(x)
	max <- max(x)
	redStart <- 5 #default value 
	greyStart <- 2
	
	yLabels <- c(rep("",nrow(x)))
	range <- aroundTSSrange
	title <-c()

	if( length(list(...)) ){
		Lst <- list(...)
		if( !is.null(Lst$zlim) ){
			min <- Lst$zlim[1]
			max <- Lst$zlim[2]
		}
		if( !is.null(Lst$title) ){
			title <- Lst$title
		}
		if(!is.null(Lst$range) ){
			range <- Lst$range
		}
		if(!is.null(Lst$greyStart) ){
			greyStart <- Lst$greyStart
		}
		if(!is.null(Lst$redStart) ){
			redStart <- Lst$redStart
		}
	}
	greyStart <- greyStart/max
	redStart <- redStart/max
	xLabels <- seq(1,ncol(x))
	xLabelLocations <- seq(1, length(xLabels), (length(xLabels)-1)/4)
	xLabels <- xLabels - ((length(xLabels)+1)/2)
	xLabels <- xLabels * (range/(length(xLabels)-1))
	xLabels <- seq(xLabels[1], xLabels[length(xLabels)], xLabels[length(xLabels)]/2) 

	layout(matrix(data=c(1,2), nrow=1, ncol=2), widths=c(4,1), heights=c(1,1))
	ColorRamp <- c(rep("#FFFFFF", 100*greyStart),grey(seq(1,0,length=(100*(redStart-greyStart)))),rep("#FF0000", 100*(1-redStart)))
	ColorLevels <- seq(min, max, length=length(ColorRamp))

	# Reverse Y axis
	reverse <- nrow(x) : 1
	x <- x[reverse,]

	# Data
	par(mar = c(3,5,2.5,2))
	image(1:ncol(x), 1:nrow(x), t(x), col=ColorRamp, xlab="", ylab="", axes=FALSE, zlim=c(min,max))
	if( !is.null(title) ){
		title(main=title)
	}
	axis(BELOW<-1, at=xLabelLocations, labels=xLabels, cex.axis=0.7)
	mtext("position relative to TSS (nucleotides)", side=1, line=2)

	# Color Scale
	par(mar = c(3,2.5,2.5,2))
	image(1, ColorLevels, matrix(data=ColorLevels, ncol=length(ColorLevels),nrow=1), col=ColorRamp, xlab="",ylab="", xaxt="n")
	mtext("coverage score color scale", side=4)
	layout(1)
}



########################## Begin MAIN CODE block ###################################
## Run Homer

if (isyes(extendReads)){
  extendedReads <- paste(outputDirectory,"/extendedReads_",estimatedFragmentSize,".bed",sep="")
  outputString1 <- paste("python ",keplerBinLocation,"/tagExtender2.py ",inputFile," ", estimatedFragmentSize," ", extendedReads, sep="")
  system(outputString1)
  outputString2 <- paste("annotatePeaks.pl tss ",genomeAssembly," -hist ", binSize, " -ghist -size ",aroundTSSrange," -p ", extendedReads, " > ", outputDirectory,"/heatMapData.txt", sep="")
  system(outputString2)
} else {
  outputString2 <- paste("annotatePeaks.pl tss ",genomeAssembly," -hist ", binSize, " -ghist -size ",aroundTSSrange," -p " ,inputFile," > ", outputDirectory,"/heatMapData.txt", sep="")
  system(outputString2)
}

fileandpathfromhomer <- paste(outputDirectory,"/heatMapData.txt", sep="") #this is the path and file created by annotatepeaks.pl from above

#####################################################################################

input <- read.table(fileandpathfromhomer, skip = 1) #MB adjusted for correct file name and to skip first line

input <- input[,-1] # remove TSS names

## Create matrix and remove any TSSs with no reads
inMatrix <- as.matrix(input)
inMatrix <- inMatrix[rowSums(inMatrix)!=0,]
## Calculate total reads for each TSS then sort the TSSs by read count and remove TSSs with no associated reads
rowScores <- rowSums(inMatrix)
inMatrix <- cbind(inMatrix,rowScores)
inMatrix <- inMatrix[order(inMatrix[,"rowScores"], decreasing=T),]
inMatrix <- inMatrix[,-ncol(inMatrix)]

if (TSStoUse == 0){
	subMatrix <- inMatrix
} else {
	subMatrix <- inMatrix[1:TSStoUse,]
}
subMatrix <- sqrt(subMatrix) # take the square root of read counts

### Create heatmap
outputFile <- paste(outputDirectory, "/", runName, "_heatmap.tif", sep="")
tiff(outputFile)
myHeatMap(subMatrix, greyStart=sqrt(lowerLimit), redStart=sqrt(upperLimit), title=paste(runName, "read coverage relative to TSS", sep=" "))
dev.off()
