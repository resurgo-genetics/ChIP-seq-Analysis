## fullPipelineScriptTKv06
## Version 6.0, Wednesday December 5th, 2014
## Created By: Nathan Cormier, Tyler Kolisnik, and Mark Bieda.

## DESCRIPTION:
# This is a program to run the full pipeline script starting from the .sam Mapped Reads file.

## Run Speed: Variable, usually one to two hours, but largely dependent on maxDremeRunTime parameter. If this parameter is set to 0 (no max run time), run time can be 20 hours or longer.

## DIRECTIONS: 
# Change the appropriate parameters within the parameter block in the initial part of this script. 
# Run the program.
# Output is numerous and varies with parameters, and will be located in the outputDirectory.

## EXAMPLE INPUT:
# inputFile <- "/home/user/inputData/GATA1.sam" 
# outputDirectory <- "/home/user/outputData/GATA1TEST"
# keplerBinLocation <- "/home/user/keplerBin"
# genomeAssembly <- "hg19" 
# transcriptionDB <- "TxDb.Hsapiens.UCSC.hg19.knownGene" 
# annotationDB <- "org.Hs.eg.db"
# runName <- "Test1" 
# extendReads <- "yes" 
# fragmentSize <- 500 
# DensityPlotBinSize <- 50
# graphWidth <- 10000
# heatmapBinSize <- 50
# heatmapWidth <- 5000
# heatmapLowerLimit <- 1
# heatmapUpperLimit <- 2
# TSStoUse <- 100
# useControl <- "no"
# controlFile <- "NA"
# trackName <- "testTrack"
# trackResolution <- 10
# maxFileSize <- 1e8
# broadCutOff <- 10000 
# upstreamRange <- 5000 
# downstreamRange <- 2000 
# GOpValueCutoff <- 0.05 
# pathway_pValueCutoff <- 0.2 
# KEGGspeciesCode <- "hsa"
# genomeDirectory <- "/home/user/keplerBin/genomes/hg19"
# DREMEeValueCutoff <- 0.001
# maxMotifsToGenerate <- 10
# maxDremeRuntime <- 3600
# titlePrefix <- "Test1" 
# useCustomYrange <- "yes"
# yMin <- 0
# yMax <- 45 

## See these examples when using different species or genome assembly, all annotation packages can be found at the bioconductor website: http://www.bioconductor.org/packages/3.0/data/annotation/.

## Example Use of Different TxDB. For Mmusculus assembly mm10:
# Visit Bioconductor website link above, find correct TxDB package in list, click link and 
# Install by running in R:
# source("http://bioconductor.org/biocLite.R")
# biocLite("TxDb.Mmusculus.UCSC.mm10.ensGene")
# Then be sure to change transcriptDB parameter to "TxDb.Mmusculus.UCSC.mm10.ensGene" and the genomeAssembly to mm10, example:
# transcriptionDB <- "TxDb.Mmusculus.UCSC.mm10.ensGene" 
# genomeAssembly <- "hg19"

## You will also have to install the correct organism annotation Db. 
# Install by running in R:
# source("http://bioconductor.org/biocLite.R")
# biocLite("org.Mm.eg.db")
# Then be sure to change the annotationDB parameter to "org.Mm.eg.db", example:
# annotationDB <- "org.Mm.eg.db"

## The genomeDirectory parameter for genomic data must also be changed. hg19 and mm18 are included by default but for any others they must be downloaded ftp://ftp.ncbi.nih.gov/genomes/ and added to the keplerBin directory.
# Change the genome directory to the new species, example for mm18:
# genomeDirectory <- "/home/user/CWF1/keplerBin/genomes/mm18"

## The KEGGspeciesCode parameter in pathway options must also be changed, "hsa"=human, "mmu"=mouse, See http://www.genome.jp/kegg/catalog/org_list.html for complete list.
# Change the KEGGspeciesCode parameter to the new species, example for mouse:
# KEGGspeciesCode <- "mmu"

## IMPORTANT HOMER SPECIES AND GENOME ASSEMBLY INFORMATION:
# The correct species and genome assembly must be installed within Homer for this program to work. 
# Note: This depends on Homer, Python and Perl being installed correctly. Homer must be in the path.

# To install this:

# Run this perl command to see potential lists of genomes, be sure to change /home/user/Homer to the correct path where you have installed Homer:
# perl /home/user/Homer//configureHomer.pl -list

# From this list get the correct genome code, hg19 = human genome assembly 19, mm10 = mus musculus 10. 
# Run this perl command to install the genome, example for mm10, be sure to change /home/user/Homer to the correct path where you have installed Homer:
# perl /home/user/Homer//configureHomer.pl -install mm10

# The genomeAssembly parameter within the parameter block  must correctly indicate the species & assembly. 
# Change the genome assembly to the new species, example for mm10:
# genomeAssembly <- "mm10"

############################# SET PARAMETERS HERE #################################

## The input file, output directory, and keplerBinLocation must be complete file paths with no trailing /
inputFile <- "/home/tylerk/massInputData/GATA1_mappedReads.sam" # This must be a mapped reads file of .sam type, this file could be generated by the mapReads.kar workflow.
outputDirectory <- "/home/tylerk/CWF1/GATA1TEST" # The directory where all output files will be located
keplerBinLocation <- "/home/tylerk/CWF1/keplerBin"# The location of the keplerBin where the python scripts are located

genomeAssembly <- "hg19"  # Assembly of genome being used, see above example for more info
transcriptionDB <- "TxDb.Hsapiens.UCSC.hg19.knownGene" # TxDb package being used, see above example for more info
annotationDB <- "org.Hs.eg.db" # The database used for annotation, see above example for more info

runName <- "fullScriptTestAcer1" # runName will be used as a prefix in the output file names

extendReads <- "yes" # If set to yes, reads will be extended, set to "no" to leave them unaltered
fragmentSize <- 500 # Numeric estimated fragment size after sonication

## TSSdensityPlot options
DensityPlotBinSize <- 50 # Numeric bin size for the TSS density plot
graphWidth <- 10000 # Numeric width of graph measured in base pairs

## heatmap options
heatmapBinSize <- 50 # Numeric bin size for the heatmap
heatmapWidth <- 5000 # Numeric width of heatmap measured in nucelotides. This is the total range of xaxis. If y=aroundTSSrange/2, then the axis goes from -y to y
heatmapLowerLimit <- 1 # Numeric lower limit of the smallest coverage value to be included on the grey scale. any coverage values below this will be white on the heatmap.
heatmapUpperLimit <- 2 # Numeric upper limit of the largest coverage value to be included on the grey scale, any coverage values above this will be red on the heatmap. If this value exceeds the maximum read density it will cause errors.
TSStoUse <- 100 # Numeric maximum number of Transcription Start Sites (TSSs) to show in the heatmap. The top scoring TSSs will be shown. Scoring is number of sequence reads within range of the TSS. Will use all possible TSSs when set to 0.


## MACS options
useControl <- "no" # Specify "yes" or "no" to use or not use a control
controlFile <- "NA" # Complete file path of control file, example: "/home/user/inputData/GATA1control_peaks.bed", no trailing /

## UCSC file options
trackName <- "GATA1 Test Track " # Specify a name for the UCSC track to be created, this name will appear once it is uploaded to the UCSC genome browser.
trackResolution <- 10 # Numeric resolution of the test track
maxFileSize <- 1e8 # Numeric maximum filesize of the test track

## peakStats options
broadCutOff <- 10000 # Numeric number of bases a peak must have to be considered a broad peak

## annotate peaks options
upstreamRange <- 5000 # Numeric maximum distance upstream of TSS to look for a peak
downstreamRange <- 2000 # Numeric maximum distance downstream of TSS to look for a peak

## GO options
GOpValueCutoff <- 0.05 # Numeric highest p value from the GO categories to include in the ouput file

## Pathway options
pathway_pValueCutoff <- 0.2  # Numeric highest p value from the pathway analysis to include in the ouput file
KEGGspeciesCode <- "hsa" # Species code from KEGG database, "hsa"= human, "mmu" = mouse, more at: http://www.genome.jp/kegg/catalog/org_list.html

## get peak sequences options
genomeDirectory <- "/home/tylerk/CWF1/keplerBin/genomes/hg19" # The directory of your genome file, within the kepler bin. hg19=human genome 19, Change if using different species or assembly!

## DREME options
DREMEeValueCutoff <- 0.001 # Numeric e value cut off for motif generation
maxMotifsToGenerate <- 10 # Numeric maximum number of motifs to generate
maxDremeRuntime <- 60  # Numeric maximum run time in seconds. This is the parameter that will affect total program run time the most. At least 1 hour is recommended (3600). Set to 0 for no limit.

## peak example options
titlePrefix <- "Test1"  # The title prefix will be added to the title of the graph creates
useCustomYrange <- "yes" # Set to "yes" to restrict y axis of the graph to custom settings. Set to "no" for automatic y axis to fit input data.
yMin <- 0 # Numeric minimum range of the y axis if useCustomYrange is set to "yes"
yMax <- 45 # Numeric maximum range of the y axis if useCustomYrange is set to "yes"
numberOfExamples <- 10 # Numeric number of peak example and non-peak example coverage plots to create
rangeAroundPeak <- 5000 # Numeric number of bases up and downstream of the peak to include in the plot
nonPeakRegionSize <- 5000 # Numeric total number of bases to include in each non-peak example coverage plot

######################################### END PARAMETER BLOCK ########################################

########################################## SAMtoBED ########################################## 

SAMfile <- inputFile
fileName <- tail(strsplit(SAMfile, "/")[[1]], n=1)
BAMfile <- paste(outputDirectory, gsub(".sam", ".bam", fileName), sep="/")
BEDfile <- paste(outputDirectory, gsub(".sam", ".bed", fileName), sep="/")
system(paste("samtools view -bS", SAMfile, ">", BAMfile, sep=" "))
system(paste("bedtools bamtobed -i",BAMfile, ">", BEDfile, sep=" "))
print("SAMtoBED completed successfully")


########################################## extendReads ########################################## 

if (extendReads == "yes"){
	pythonCommand <- paste("python ", keplerBinLocation, "/tagExtender2.py", sep="") 
	extendedReads <- paste(outputDirectory, "/", runName, "_extendedReads_", fragmentSize, ".bed", sep="")
	system(paste(pythonCommand,  BEDfile, fragmentSize, extendedReads, sep=" "))
} else {
	extendedReads <- BEDfile
}
print("extendReads completed successfully")

########################################## TSSdensityPlot ########################################## 
## errors occur when running in R studio, but works fine when run as an Rscript. This is an Rstudio problem, not a script problem
tagDensityFile <- paste(outputDirectory, "/", runName, "_TSStagDensities.txt", sep="")
system(paste("annotatePeaks.pl tss", genomeAssembly, "-hist", DensityPlotBinSize, "-size", graphWidth, "-p", extendedReads, ">", tagDensityFile, sep=" "))

dataIn <- read.table(tagDensityFile, skip = 1)
pdf(paste(outputDirectory, "/", runName, "_densityPlot.pdf", sep=""))
plot(x=dataIn$V1, y=dataIn$V2, type="l", xlab="Distance from TSS", ylab="Tag Density (per bp per TSS)")
dev.off()
print("TSSdensityPlot completed successfully")

########################################## TSS heatmap ########################################## 
heatMapData <- paste(outputDirectory, "/", runName, "_heatmapData.txt", sep="")
system(paste("annotatePeaks.pl tss", genomeAssembly, "-hist", heatmapBinSize, "-ghist", "-size", heatmapWidth, "-p", extendedReads, ">", heatMapData, sep=" "))

## Function to create a heatmap from a data matrix
myHeatMap <- function(x, ...){
	min <- min(x)
	max <- max(x)
	redStart <- 5
	greyStart <- 2
	
	yLabels <- c(rep("",nrow(x)))
	range <- 10000
	title <-c()

	if( length(list(...)) ){
		Lst <- list(...)
		if( !is.null(Lst$zlim) ){
			min <- Lst$zlim[1]
			max <- Lst$zlim[2]
		}
		if( !is.null(Lst$title) ){
			title <- Lst$title
		}
		if(!is.null(Lst$range) ){
			range <- Lst$range
		}
		if(!is.null(Lst$greyStart) ){
			greyStart <- Lst$greyStart
		}
		if(!is.null(Lst$redStart) ){
			redStart <- Lst$redStart
		}
	}
	greyStart <- greyStart/max
	redStart <- redStart/max
	xLabels <- seq(1,ncol(x))
	xLabelLocations <- seq(1, length(xLabels), (length(xLabels)-1)/4)
	xLabels <- xLabels - ((length(xLabels)+1)/2)
	xLabels <- xLabels * (range/(length(xLabels)-1))
	xLabels <- seq(xLabels[1], xLabels[length(xLabels)], xLabels[length(xLabels)]/2) 

	layout(matrix(data=c(1,2), nrow=1, ncol=2), widths=c(4,1), heights=c(1,1))
	ColorRamp <- c(rep("#FFFFFF", 100*greyStart),grey(seq(1,0,length=(100*(redStart-greyStart)))),rep("#FF0000", 100*(1-redStart)))
	ColorLevels <- seq(min, max, length=length(ColorRamp))

	#Reverse Y axis
	reverse <- nrow(x) : 1
	x <- x[reverse,]

	# Data Map
	par(mar = c(3,5,2.5,2))
	image(1:ncol(x), 1:nrow(x), t(x), col=ColorRamp, xlab="", ylab="", axes=FALSE, zlim=c(min,max))
	if( !is.null(title) ){
		title(main=title)
	}
	axis(BELOW<-1, at=xLabelLocations, labels=xLabels, cex.axis=0.7)
	mtext("position relative to TSS (nucleotides)", side=1, line=2)

	# Color Scale
	par(mar = c(3,2.5,2.5,2))
	image(1, ColorLevels, matrix(data=ColorLevels, ncol=length(ColorLevels),nrow=1), col=ColorRamp, xlab="",ylab="", xaxt="n")
	mtext("coverage score color scale", side=4)
	layout(1)
}

input <- read.table(heatMapData, skip=1) # read in the input data, skipping the header line

input <- input[,-1] # remove TSS names
print("check 1")

## create matrix and remove any TSSs with no reads
inMatrix <- as.matrix(input)
inMatrix <- inMatrix[rowSums(inMatrix)!=0,]
## Calculate total reads for each TSS then sort the TSSs by read count and remove TSSs with no associated reads
rowScores <- rowSums(inMatrix)
inMatrix <- cbind(inMatrix,rowScores)
inMatrix <- inMatrix[order(inMatrix[,"rowScores"], decreasing=T),]
inMatrix <- inMatrix[,-ncol(inMatrix)]

print("check 2")
if (TSStoUse == 0){
	subMatrix <- inMatrix
} else {
	subMatrix <- inMatrix[1:TSStoUse,]
}
subMatrix <- sqrt(subMatrix) # take the square root of read counts

###create heatmap
print("check 3")
outputFile <- paste(outputDirectory, "/", runName, "_heatmap.pdf", sep="")
pdf(outputFile)
myHeatMap(subMatrix, greyStart=sqrt(heatmapLowerLimit), redStart=sqrt(heatmapUpperLimit), title=paste(runName, "read coverage relative to TSS", sep=" "))
dev.off()
print("heatMap completed successfully")

########################################## runMACS ########################################## 

if (useControl == "yes"){
	system(paste("macs14 -t", BEDfile, "-c", controlFile, "-f BED -g hs -n", paste(outputDirectory, runName, sep="/"), sep=" "))
} else {
	system(paste("macs14 -t", BEDfile, "-f BED -g hs -n", paste(outputDirectory, runName, sep="/"), sep=" "))
}

MACSpeakFile <- paste(outputDirectory, "/", runName, "_peaks.bed", sep="")

########################################## indexBAM ########################################## 

outputFileName <- gsub(".bam", "_sorted", BAMfile)
system(paste("samtools sort", BAMfile, outputFileName, sep=" "))
sortedBAMfile <- paste(outputFileName, ".bam", sep="")
system(paste("samtools index", sortedBAMfile, sep=" "))
system(paste("mv ", sortedBAMfile, ".bai ", gsub(".bam", ".bai", sortedBAMfile), sep =""))

########################################## createUCSCfile ########################################## 
## currently untested
tagDirectory <- paste(outputDirectory, "tagDirectory", sep="/")
outputFileName <- paste(outputDirectory, "/", runName, "_UCSCtrack", sep="")

system(paste("makeTagDirectory", tagDirectory, sortedBAMfile, sep=" "))
system(paste("makeUCSCfile", tagDirectory, "-o", outputFileName, "-name", trackName, "-res", trackResolution, "-color 0,0,0 -fsize", maxFileSize, sep=" "))

########################################## peakStats ########################################## 

genomeSizeFile <- paste(outputDirectory, "/", runName, "_chromosomeSizes.txt", sep="")
shellCommand <- paste("sh ", keplerBinLocation, "/fetchChromSizes.sh", sep="")
system(paste(shellCommand, genomeAssembly, ">", genomeSizeFile, sep=" "))
outputFile <- paste(outputDirectory, "/", runName, "_peakStats.txt", sep="")
dataIn <- read.table(MACSpeakFile)

totalPeaks <- nrow(dataIn) # count number of peaks
dataIn$peakLength <- dataIn$V3 - dataIn$V2
smallestPeak <- min (dataIn$peakLength) # find size of the smallest peak
largestPeak <- max (dataIn$peakLength) # find size of the largest peak
meanLength <- mean(dataIn$peakLength) # find the mean peak length
SD <- sd(dataIn$peakLength) # find the standard deviation of the peak length
medianLength <- median(dataIn$peakLength) # find the median peak length

## calculates the total genome size from the genomeSize input file if necessary
if (!is.na(suppressWarnings(as.numeric(genomeSizeFile)))) {
	totalBases <- as.numeric(genomeSizeFile)
} else {
	lengths <- read.table(genomeSizeFile)
	trimmedLengths <- lengths[!grepl(".*_.*", lengths$V1), ]
	totalBases <- sum(as.numeric(lengths$V2))
}
coveragePercent <- (sum(dataIn$peakLength)/totalBases) * 100 # calculates % of genome covered in peaks

## determines how many peaks are classified as broad and what percentage of the total peaks this is
broad <- dataIn[dataIn$peakLength > broadCutOff, ]
narrow <- dataIn[dataIn$peakLength <= broadCutOff, ]
broadPercent <- (nrow(broad)/nrow(dataIn)) * 100

## set up the data for the output file
totalPeaks_str <- paste("Total number of peaks:", totalPeaks, sep="\t")
smallestPeak_str <- paste("Min peak length (bp):", smallestPeak, sep="\t")
largestPeak_str <- paste("Max peak length (bp):", largestPeak, sep="\t")
meanLength_str <- paste("Mean peak length (bp):", round(meanLength, digits=3), sep="\t")
SD_str <- paste("Peak length standard deviation:", round(SD, digits=3), sep="\t")
medianLength_str <- paste("Median peak length (bp):", medianLength, sep="\t")
broad_str <- paste("number of peaks longer than ", broadCutOff/1000, " kb:\t", nrow(broad), sep="")
broadPercent_str <- paste("% of peaks larger than ", broadCutOff/1000, " kb:\t", round(broadPercent, digits=3), sep="")
coveragePercent_str <- paste("% of genome with peaks:", round(coveragePercent, digits=3), sep="\t")

## calculates the number of peaks on each chromosome and sets up output string
chrDistro_str <- paste("Number of peaks per chromosome:", "\n")
for (i in 1:22){
	chrNum <- paste("chr", i, sep="")
	temp <- nrow(dataIn[(dataIn$V1 == chrNum), ])
	chrDistro_str <- paste(chrDistro_str, chrNum, temp, "\n", sep="\t")
}

## adds the correct chromosome symbol to the non-numeric chromosomes	
chrNum <- "chrX"
temp <- nrow(dataIn[(dataIn$V1 == chrNum), ])
chrDistro_str <- paste(chrDistro_str,chrNum, temp, "\n", sep="\t")
chrNum <- "chrY"
temp <- nrow(dataIn[(dataIn$V1 == chrNum), ])
chrDistro_str <- paste(chrDistro_str,chrNum, temp, "\n", sep="\t")
chrNum <- "chrM"
temp <- nrow(dataIn[(dataIn$V1 == chrNum), ])
chrDistro_str <- paste(chrDistro_str,chrNum, temp, "\n", sep="\t")

## writes the output string to file
stringOutput <- paste(totalPeaks_str, smallestPeak_str, largestPeak_str, medianLength_str, meanLength_str, SD_str, coveragePercent_str, broad_str, broadPercent_str, chrDistro_str, sep="\n")

writeLines(stringOutput, outputFile)

########################################## distanceToTSS ########################################## 

## takes in a set of peak data in .bed format
## uses the specified TxDb to calculate distances between each peak and its nearest TSS
## see the bioconductor website for a list of available TxDbs

## Load required libraries
library(transcriptionDB, character.only=TRUE)
library(GenomicRanges)
library(rtracklayer)
assign("txdb", get(transcriptionDB))

## function pull the TSS from the correct stands of the TxDb data
grabTSS <- function(x){
	if(x[3]=="-"){
		x[length(x)+1] <- as.integer(x[5])
	}
	else{
		x[length(x)+1] <- as.integer(x[4])
	}
	#str(x)
	return(x)
}

## extract data from the TxDb
keys <- keys(txdb, keytype="TXID")
columns=c("TXSTART", "TXEND","TXSTRAND", "TXCHROM")
TSSdata <- select(txdb, keys=keys, columns=columns, keytype="TXID")
TSSdata <- data.frame(t(apply(TSSdata, 1, grabTSS)))
TSSdata$V6 <- as.numeric(levels(TSSdata$V6))[TSSdata$V6]

## create Granges object for the TSSs
TSSranges <- GRanges(seqnames = Rle(TSSdata$TXCHROM),
ranges = IRanges(as.numeric(TSSdata$V6), as.numeric(TSSdata$V6)),
strand = Rle(TSSdata$TXSTRAND))

peaks <- import.bed(con=MACSpeakFile, asRangedData=F) # read in peaks as a Grange object

distances <- as.data.frame(distanceToNearest(peaks, TSSranges)) # calculate distance between each peak and its nearest TSS

## determine number of peaks which fall into each distance interval
overlap <- nrow(distances[distances$distance==0,])
under1kb <- nrow(distances[distances$distance<=1000 & distances$distance>0,])
under2kb <- nrow(distances[distances$distance<=2000 & distances$distance>1000,])
under5kb <- nrow(distances[distances$distance<=5000 & distances$distance>2000,])
under10kb <- nrow(distances[distances$distance<=10000 & distances$distance>5000,])
under20kb <- nrow(distances[distances$distance<=20000 & distances$distance>10000,])
over20 <- nrow(distances[distances$distance>20000,])

## format data for output file
overlap <- paste("overlapping TSS", overlap, sep="\t")
within1Kb <- paste("within 1Kb of TSS", under1kb, sep="\t")
within2Kb <- paste("between 1Kb and 2Kb", under2kb, sep="\t")
within5Kb <- paste("between 2Kb and 5Kb", under5kb, sep="\t")
within10Kb <- paste("between 5Kb and 10Kb", under10kb, sep="\t")
within20Kb <- paste("between 20Kb and 10Kb", under20kb, sep="\t")
over20Kb <- paste("over 20Kb from TSS", over20, sep="\t")
outString <- "Number of peaks within set intervals of the TSS"
outString <- paste(outString, overlap, within1Kb, within2Kb, within5Kb, within10Kb, within20Kb, over20Kb, sep="\n")

## print output to file
outputFile <- paste(outputDirectory, "/", runName, "_distanceToTSSdata.txt", sep="")
writeLines(outString, outputFile)

########################################## annotatePeaks ########################################## 

library(transcriptionDB, character.only=TRUE)
assign("txdb", get(transcriptionDB))
library(annotationDB, character.only=TRUE)
assign("annotdb", get(annotationDB))
library(GenomicRanges)
library(rtracklayer)

peaks <- import.bed(con=MACSpeakFile, asRangedData=F)
start(peaks) <- start(peaks)-1

#function for extending the TSS to the ranges specified by upstreamRange and downstreamRange
extendTSS <- function(x){
	if(x[5]=="-"){
		x[length(x)+1] <- as.integer(x[7])
		x[length(x)+1] <- as.integer(x[7])-downstreamRange
		x[length(x)+1] <- as.integer(x[7])+upstreamRange
	}
	else{
		x[length(x)+1] <- as.integer(x[6])
		x[length(x)+1] <- as.integer(x[6])-upstreamRange
		x[length(x)+1] <- as.integer(x[6])+downstreamRange
	}
	return(x)
}

## get information from the TxDb and extend the TSSs
keys <- keys(txdb, keytype="TXID")
columns=c("TXSTART", "TXEND","TXSTRAND", "TXCHROM", "GENEID", "TXNAME")
TSSdata <- select(txdb, keys=keys, columns=columns, keytype="TXID")
TSSdata <- data.frame(t(apply(TSSdata, 1, extendTSS)))
TSSdata$V8 <- as.numeric(levels(TSSdata$V8))[TSSdata$V8]
TSSdata$V9 <- as.numeric(levels(TSSdata$V9))[TSSdata$V9]
TSSdata$V10 <- as.numeric(levels(TSSdata$V10))[TSSdata$V10]

## create Granges object for the TSS ranges
TSSranges <- GRanges(seqnames = Rle(TSSdata$TXCHROM),
ranges = IRanges(as.numeric(TSSdata$V9), as.numeric(TSSdata$V10)),
strand = Rle(TSSdata$TXSTRAND), entrezID=TSSdata$GENEID, UCSCID=TSSdata$TXNAME, TSS=TSSdata$V8)

## find overlaps between peak data and TSS ranges
peakData <- data.frame(as.character(seqnames(peaks)), ranges(peaks), peaks@elementMetadata) 
TSSdata <- data.frame(TSSranges@elementMetadata)
overlap <- findOverlaps(peaks,TSSranges)

## extract overlapping peaks and associated data
outputData <- data.frame(as.character(seqnames(peaks))[queryHits(overlap)], ranges(peaks)[queryHits(overlap)], 
peaks@elementMetadata[queryHits(overlap),],ranges(TSSranges)[subjectHits(overlap)], TSSranges@elementMetadata[subjectHits(overlap),], 
strand(TSSranges)[subjectHits(overlap)])
colnames(outputData)[1] <- "chromosome"
colnames(outputData)[13] <- "strand"
colnames(outputData)[which(colnames(outputData)=="start")] <- "peak start"
colnames(outputData)[which(colnames(outputData)=="end")] <- "peak end"
colnames(outputData)[which(colnames(outputData)=="name")] <- "peak name"
colnames(outputData)[which(colnames(outputData)=="UCSCID")] <- "UCSC_ID"
colnames(outputData)[which(colnames(outputData)=="TXSTART")] <- "TSS"
colnames(outputData)[which(colnames(outputData)=="GENEID")] <- "entrez ID"
colnames(outputData)[which(colnames(outputData)=="start.1")] <- "TSS_region_start"
colnames(outputData)[which(colnames(outputData)=="end.1")] <- "TSS_region_end"

## remove extra data fields
drops <- c("width", "TXCHROM", "width.1")
outputData <- outputData[,!(names(outputData) %in% drops)]

## get additional data from the annotationDB
keys <- keys(annotdb, keytype="UCSCKG")
columns=c("SYMBOL","GENENAME")
annotData <- select(annotdb, keys=keys, columns=columns, keytype="UCSCKG")

## add new annotation data to the previous data list
colnames(annotData)[which(colnames(annotData)=="UCSCKG")] <- "UCSC_ID"
colnames(annotData)[which(colnames(annotData)=="SYMBOL")] <- "Gene_Symbol"
colnames(annotData)[which(colnames(annotData)=="GENENAME")] <- "Full Gene Name"
outputData <- merge(outputData, annotData, by="UCSC_ID")
outputData <- outputData[c(2:6, 10, 7:8, 11, 9, 1, 12:13)]

## write data tables to file
symbolList <- unique(outputData$Gene_Symbol)
annotationFile <- paste(outputDirectory, "/", runName, "_", upstreamRange, "up_", downstreamRange, "down_allData.txt", sep="")
symbolFile <- paste(outputDirectory, "/", runName, "_", upstreamRange, "up_", downstreamRange, "down_geneSymbols.txt", sep="")
write.table(outputData, file=annotationFile,append=FALSE, quote=FALSE, sep="\t", eol = "\n", row.name=FALSE, col.name=TRUE)
write.table(symbolList, file=symbolFile,append=FALSE, quote=FALSE, sep="\t", eol = "\n", row.name=FALSE, col.name=FALSE)

########################################## GO analysis ########################################## 

## Load required libraries
library(annotationDB, character.only=TRUE)
library(GOstats)
assign("annotdb", get(annotationDB))

symbolList <- read.delim(symbolFile) # read in input file 
symbolList <- as.character(symbolList[[1]])

#symbolList <- as.character(symbolList$Gene_Symbol) # get list of gene symbols from the input file

## convert the input gene symbols into entrez IDs
geneList <- select(annotdb, keys=symbolList, columns="ENTREZID", keytype="SYMBOL") 
geneUniverse <- keys(annotdb, keytype="ENTREZID")
GOstatsGenes <- as.character(geneList$ENTREZID)

## perform GO enrichment analysis on BP terms
paramsBP <- new("GOHyperGParams", geneIds=GOstatsGenes, universeGeneIds=geneUniverse,
annotation=annotationDB, ontology="BP", pvalueCutoff=GOpValueCutoff, conditional=TRUE,
testDirection="over")

## perform GO enrichment analysis on CC terms
paramsCC <- new("GOHyperGParams", geneIds=GOstatsGenes, universeGeneIds=geneUniverse,
annotation=annotationDB, ontology="CC", pvalueCutoff=GOpValueCutoff, conditional=TRUE,
testDirection="over")

## perform GO enrichment analysis on MF terms
paramsMF <- new("GOHyperGParams", geneIds=GOstatsGenes, universeGeneIds=geneUniverse,
annotation=annotationDB, ontology="MF", pvalueCutoff=GOpValueCutoff, conditional=TRUE,
testDirection="over")

## format GO enrichment analysis for output
BP_GOdata <- hyperGTest(paramsBP)
BP_Summ <- summary(BP_GOdata)
BP_Summ <- data.frame(BP_Summ[1], BP_Summ[7], BP_Summ[2:6])
CC_GOdata <- hyperGTest(paramsCC)
CC_Summ <- summary(CC_GOdata)
CC_Summ <- data.frame(CC_Summ[1], CC_Summ[7], CC_Summ[2:6])
MF_GOdata <- hyperGTest(paramsMF)
MF_Summ <- summary(MF_GOdata)
MF_Summ <- data.frame(MF_Summ[1], MF_Summ[7], MF_Summ[2:6])

## write GO analysis outputs to file
outputFile <- paste(outputDirectory, "/", runName, sep="")

write.table(BP_Summ, file=paste(outputFile,"_BP.txt",sep=""), quote=FALSE, sep="\t", eol = "\n", row.name=FALSE, col.name=TRUE)
write.table(CC_Summ, file=paste(outputFile,"_CC.txt",sep=""), quote=FALSE, sep="\t", eol = "\n", row.name=FALSE, col.name=TRUE)
write.table(MF_Summ, file=paste(outputFile,"_MF.txt",sep=""), quote=FALSE, sep="\t", eol = "\n", row.name=FALSE, col.name=TRUE)

## combine all GO analysis outputs into one file sorted by p values
colnames(MF_Summ)[1] <- "GOID"
colnames(BP_Summ)[1] <- "GOID"
colnames(CC_Summ)[1] <- "GOID"
temp <- merge(MF_Summ, BP_Summ, all=T)
ALL_Summ <- merge(temp, CC_Summ, all=T)
ALL_Summ <- ALL_Summ[with(ALL_Summ,order(Pvalue)),]
## write data to file.
write.table(ALL_Summ, file=paste(outputFile,"_ALL.txt",sep=""), quote=FALSE, sep="\t", eol = "\n", row.name=FALSE, col.name=TRUE)

########################################## gagePathwayAnalysis ########################################## 

library(gage)
library(pathview)
pathwayDirectory <- paste(outputDirectory, "pathway_images", sep="/")
system(paste("mkdir ", pathwayDirectory, sep = ""))
setwd(pathwayDirectory)

## gets the list of entrez genes and their associated peak scores from the input file
geneData <- unique(read.delim(annotationFile)[,c("entrezID", "score")])
geneList <- unique(geneData$entrezID)
geneList <- geneList[!is.na(geneList)]
dataMatrix <- matrix(data=NA, nrow=length(geneList), ncol=1) 
rownames(dataMatrix) <- geneList
colnames(dataMatrix) <- "score"

## for each unique entrez gene, finds the highest peak score associated with that gene
for (i in 1:length(geneList)) {
	gene <- as.character(geneList[i])
	#print(gene)
	score <- max(geneData$score[which(geneData$entrezID == gene)])
	dataMatrix[gene,] <- score
}


data(kegg.gs) # load in the KEGG pathway data
gageOutput <- gage(dataMatrix, gsets = kegg.gs, samp=1) # determines which pathways are enriched in the data set
pathwayData <- gageOutput$greater[,c("p.val", "q.val")]
pathCode <- substr(rownames(pathwayData), 1, 8)
pathName <- substr(rownames(pathwayData), 9, length(rownames(pathwayData)))
pathwayData <- cbind(pathCode, pathName ,pathwayData)
colnames(pathwayData) <- c("Pathway Code", "Pathway Name", "p Values", "q value")
write.table(pathwayData, paste(runName, "full_pathway_list", sep="_"), sep="\t", row.names=FALSE, quote = FALSE)

## get enriched pathways with a p value less than the cutoff value
sel <- gageOutput$greater[,"p.val"] < pathway_pValueCutoff & !is.na(gageOutput$greater[,"p.val"])
pathIds <- substr(rownames(gageOutput$greater)[sel], 1, 8)

## Use pathview to create output images
runPathview <- function(pid){
	print(pid)
	pathview(gene.data=dataMatrix, pathway.id=pid, species=KEGGspeciesCode)
	system(paste("rename 's/^/", runName, "_/' ", pid, "*", sep=""))
	}
pathList <- sapply(pathIds, function(pid) runPathview(pid))

########################################## getPeakSequences ########################################## 

pythonCommand <- paste("python ", keplerBinLocation, "/getPeakSequences.py", sep="")
peakSequenceFile=paste(outputDirectory, "/", runName, "_peakSequences.fa", sep="")
system(paste(pythonCommand, MACSpeakFile, genomeDirectory, peakSequenceFile, sep=" "))

########################################## runDREME ########################################## 

dremeOutputDirectory <- paste(outputDirectory, "/", runName, "_DREME_output", sep="")
system(paste("dreme -oc", dremeOutputDirectory, "-p", peakSequenceFile, "-t", maxDremeRuntime, "-m", maxMotifsToGenerate, "-e", DREMEeValueCutoff, "-desc -l", sep=" "))

########################################## makePeakExamples ########################################## 

library(GenomicRanges)
library(GenomicAlignments)
exampleDirectory <- paste(outputDirectory, "peak_examples", sep="/")
system(paste("mkdir ", exampleDirectory, sep=""))

## function to create the plots with the automatic y axis range
plotCovDefault <- function(mycov=cov, mychr=1, mypos=c(1,1000), mymain="Coverage", ...) {
	op <- par(mar=c(8,5,6,1))
	plot(as.numeric(mycov[[mychr]][mypos[1]:mypos[2]]), type="l",
	lwd=1, col="blue", ylab="Tag Count", main=mymain, xlab="", xaxt="n", ...)
	axis(1, las = 2, at=seq(1,mypos[2]-mypos[1], length.out= 10),
	labels=as.integer(seq(mypos[1], mypos[2], length.out= 10)))
	mtext(paste("Chromosome position (", mychr, ")", sep=""), side=1, line=6)
	par(op)
}

## function to create the same plot but with a fixed y axis
plotCovCustom <- function(mycov=cov, mychr=1, mypos=c(1,1000), mymain="Coverage", ...) {
	op <- par(mar=c(8,5,6,1))
	plot(as.numeric(mycov[[mychr]][mypos[1]:mypos[2]]), type="l",
	lwd=1, col="blue",ylim=c(yMin, yMax), ylab="Tag Count", main=mymain, xlab="", xaxt="n", ...)
	axis(1, las = 2, at=seq(1,mypos[2]-mypos[1], length.out= 10),
	labels=as.integer(seq(mypos[1], mypos[2], length.out= 10)))
	mtext(paste("Chromosome position (", mychr, ")", sep=""), side=1, line=6)
	par(op)
}

peaks <- read.table(MACSpeakFile)
## sort peaks by score and take top scoring examples +- the specified range around them
peaks <- peaks[order(peaks$V5, decreasing=T),]
POI <- peaks[1:numberOfExamples,]
range <- rangeAroundPeak
POI$V2 <- POI$V2-range
POI$V3 <- POI$V3+range

## read in sequences from the .bam file which overlap the peak range
which <- GRanges(POI$V1, IRanges(POI$V2, POI$V3))
param <- ScanBamParam(which=which)
reads <- readGAlignments(sortedBAMfile, param=param)

## removes extra chr length data from the Granges object
seqlevels(reads) <- seqlevels(reads)[seqlevels(reads) %in% as.character(POI$V1)]
cov <- coverage(reads) # get the total coverage at each base in the specified range

if (useCustomYrange!="yes") { 
	## checks to make sure the graph does not extend past the end of its chromosome
	for (i in 1:numberOfExamples){
		jpeg(file=paste(exampleDirectory, "/", runName, "_peak",i,".jpeg",sep=""))
		rangeMax <- sum(cov[[as.character(POI$V1[i])]]@lengths)
		if (POI$V2[i] < 0) {
			POI$V2[i] <- 0
		}
		if (POI$V3[i] > rangeMax) {
			POI$V3[i] <- rangeMax
		}
		## create the plots using automatic y axis scales for each plot
		plot <- plotCovDefault(mycov=cov, mychr=as.character(POI$V1[i]), mypos=c(POI$V2[i],POI$V3[i]), mymain=paste(titlePrefix, POI$V1[i],POI$V2[i],"-",POI$V3[i], sep=" "))
		dev.off()
	}
} else { 
	## checks to make sure the graph does not extend past the end of its chromosome
	for (i in 1:numberOfExamples){
		jpeg(file=paste(exampleDirectory, "/", runName, "_peak",i,".jpeg",sep=""))
		rangeMax <- sum(cov[[as.character(POI$V1[i])]]@lengths)
		if (POI$V2[i] < 0) {
			POI$V2[i] <- 0
		}
		if (POI$V3[i] > rangeMax) {
			POI$V3[i] <- rangeMax
		}
		## create the plots using the set y axis
		plot <- plotCovCustom(mycov=cov, mychr=as.character(POI$V1[i]), mypos=c(POI$V2[i],POI$V3[i]), mymain=paste(titlePrefix, POI$V1[i],POI$V2[i],"-",POI$V3[i], sep=" "))
		dev.off()
	}

}

###################################################################
## creates a list of locations which are between peaks and likely have very few reads
## the regions with the least (but not zero) sequence reads are plotted
## This script assumes that the peak file is fairly large (several thousand peaks)
## and it may not work correctly if the file is very small

## pick a set of peaks evenly spaced across the peak file
peaks <- peaks[order(peaks$V1), ]
peakChecks <- numberOfExamples*10
negativeList <- data.frame(chr=(character()), start=(integer()), end=(integer()))
cut <- floor(nrow(peaks)/peakChecks)
regionSize <- nonPeakRegionSize/2

## Select a region in between each chosen peak and the previous peak in the input file
for (i in 1:peakChecks){
	x <- peaks[i*cut, ]
	y <- peaks[(i*cut)-1, ]
	if (x[1] == y[1]){
		midpoint = floor((y$V3 + x$V2)/2)
		newRow <- x[1:3]
		newRow[2] <- midpoint - regionSize
		newRow[3] <- midpoint + regionSize
		negativeList <- rbind(negativeList, newRow)
	}

}

## read in sequences from the .bam file which overlap the range
which <- GRanges(negativeList$V1, IRanges(negativeList$V2, negativeList$V3))
param <- ScanBamParam(which=which)
reads <- readGAlignments(sortedBAMfile, param=param)	
seqlevels(reads) <- seqlevels(reads)[seqlevels(reads) %in% as.character(negativeList$V1)]
cov <- coverage(reads) # get the total coverage at each base in the specified range
totalReads <- c()

## checks to make sure the graph does not extend past the end of its chromosome
for (i in 1:nrow(negativeList)){
	rangeMax <- sum(cov[[as.character(negativeList$V1[i])]]@lengths)
	if (negativeList$V2[i] < 0) {
		negativeList$V2[i] <- 0
	}
	if (negativeList$V3[i] > rangeMax) {
		negativeList$V3[i] <- rangeMax
	}
	totalReads <- append(totalReads, sum(cov[[as.character(negativeList$V1[i])]][negativeList$V2[i]:negativeList$V3[i]]))
}

## Sorts possible negative regions by total coverage, removing any regions with no sequence reads
## the regions with the lowest total sequence reads are graphed
negativeList[,"reads"] <- totalReads
negativeList <- negativeList[order(negativeList$reads), ]
negativeList <- negativeList[!(negativeList$reads==0), ]
negativeList <- negativeList[1:numberOfExamples, ]
if (useCustomYrange!="yes") {	# create the plots using automatic y axis scales for each plot
	for (i in 1:numberOfExamples){
		jpeg(file=paste(exampleDirectory, "/", runName, "_NonPeakRegion",i,".jpeg",sep=""))
		plot <- plotCovDefault(mycov=cov, mychr=as.character(negativeList$V1[i]), mypos=c(negativeList$V2[i],negativeList$V3[i]), 
		mymain=paste(titlePrefix, negativeList$V1[i],negativeList$V2[i],"-",negativeList$V3[i], sep=" "))
		dev.off()
	}
} else {
	for (i in 1:numberOfExamples){ # create the plots using the set y axis
		jpeg(file=paste(exampleDirectory, "/", runName, "_NonPeakRegion",i,".jpeg",sep=""))
		plot <- plotCovCustom(mycov=cov, mychr=as.character(negativeList$V1[i]), mypos=c(negativeList$V2[i],negativeList$V3[i]), 
		mymain=paste(titlePrefix, negativeList$V1[i],negativeList$V2[i],"-",negativeList$V3[i], sep=" "))
		dev.off()
	}

}
